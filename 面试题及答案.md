Q:CSS 盒子模型，绝对定位和相对定位
A1:
    1:css盒子模型分为IE盒子模型和W3C盒子模型;
    2:IE盒子模型 width=border+padding+margin+content; W3C标准模型 width=content(各大浏览器适用);
    3:IE盒子模型和标准盒子模型之间的转换 box-sizing：border-box（IE盒子模型） content-box(标准盒子模型);
    4:box-sizing:inherit|border-box|content-box
A2:
    1:absoulte(绝对定位)--相对于父元素进行定位|relative(相对定位)--相对于浏览器进行定位;
    2:position:static|absoult|reative|fixed|inherit;

<----------------------------------------------------------------------------------------------->

Q:清除浮动，什么时候需要清除浮动，清除浮动都有哪些方法
A1:
    1:clear:both|left(使)|right; overflow:hidden|auto;
    2:当子元素设置了浮动属性父元素没有设置高度的时候导致的父元素的高度坍塌（高度完全由子元素撑起）;
<!--   .a{
            background: #eeeeee;   
            overflow：hidden|auto;
        }
        .b{
            float: left;
            background: #333;
            width: 100px;
            height: 100px;
        }
        .c{
            float: left;
            width: 100px;
            height: 100px;
            background: green
        }
        .d{
            float: left;
            height: 100px;
            width: 100px;
            background: saddlebrown
        }
        .e{
             clear: both; (方法一)
        }-->
<div class="a"> 
    <div class="b"></div>
    <div class="c"></div>
    <div class="d"></div>
    <div class="e"></div>
</div>
3:clear:both|left(使)|right; overflow:hidden|auto;
Q:如何保持浮层水平垂直居中
A:
1:
<!-- .a{
    position:absoult;
    left:0;
    top:0;
    right:0;
    bottom:0;
    margin:auto;
    }
    .a{
    transform: translate(-50%,-50%);
    position: absolute;
    top: 50%;
    background: #eeeeee;
    left: 50%;
    }
 -->
<div class="a"></div>

<---------------------------------------------------------------------->

Q: position 和 display 的取值和各自的意思和用法
A:
1:position:absoult(相对于父元素进行定位)|relative(相对于浏览器定位)|static(无定位)|fixed(固定定位)|inherit;
2:display:none(隐藏元素)|block|inline-block(让行内元素变成行内块级元素)|inherit  (常用);

<---------------------------------------------------------------------->

Q:样式的层级关系，选择器优先级，样式冲突，以及抽离样式模块怎么写，说出思路，有无实践经验
A1:
1: example:
<ul>
    <li></li>
    <li></li>
    <li></li>
</ul>
2:!important > id > class > :after , :before;
3:选择器会后面的样式覆盖前面的;
4:抽离模块

<---------------------------------------------------------------------->

Q:  px和em和rem的区别，CSS中link 和@import的区别是? 
 A1:
  1:px用于电脑的定义多一点 rem 用于移动端的多一点(适合做兼容式布局);
  2:rem相对于html元素(根元素)的font-size进行计算;（相对尺寸）
  3:px绝对尺寸设置多少就是多少
  4：em相对于父元素的font-size进行计算（相对尺寸）eg：1em=16px
A2:
  1:link是和dom渲染同时加载 link属于html元素 link可以定义rel等规范;
  2:@import是等到dom渲染完成之后才开始加载;

<---------------------------------------------------------------------->

Q:JavaScript 里有哪些数据类型，解释清楚 null 和 undefined，解释清楚原始数据类型和引用数据类型。比如讲一下 1 和 Number(1)的区别
A1:
    1:基础类型：null,undefined,boolean,string,number;
    2:引用数据类型：object,Array....;
A2:
    1:typeOf null -> object, typeOf undefined -> undefined ;
    2:null代表空指针;
A3:
    1:基础数据类型是存放在内存当中的栈当中的;
    2:用数据类型是存放在堆当中的;
A4:
    1: 1属于原始对象 number(1)属于包装对象

<---------------------------------------------------------------------->

Q:prototype 是什么东西，原型链的理解，什么时候用 prototype
A1：
    1:在每一个FUNTION中都有一个prototype属性,prototype代表该方法的原型;
    2:当使用 let Params=new functionName() 的时候会发生以下事情
        (1):创建出一个新的对象
        (2)执行functionName()里边的方法;
        (3)将params的this指向构造函数(functionName);
        (4)最后将创建出的对象中的__proto__==functionName.prototype;
    3:当需要创建对象的时候子类需要用到父类的方法 而且父类的原始方法不受到干扰;

<---------------------------------------------------------------------->

Q:函数里的this什么含义，什么情况下，怎么用
A1:
    1:this是一个关键字 当创建一个对象或者方法的时候就会产生一个this关键字;
    2:this总是指向调用时候的对象;(如果被多个对象调用的话就指向上一层对象)
    3:箭头函数的this指向上下文
A2:
    1:函数的调用
    2:构造方法时的调用
    3：作为方法的时候调用
    4:apply|call|bind的调用
A3:
    A2_1:作为函数的调用
        function demo(){
            this.a='this is a demo';
            console.log(this.a)
        }
        demo() //this is a demo //this指向window;
    A2_2:构造方法时调用
        function demo(){
            this.a='this is a demo';
        }
        let seconde_demo=new demo();
        console.log(seconde_demo.a) //this is a demo //this指向当前的demo构造函数
    A2_3:作为方法的时候调用
        function demo(){
    　　　　alert(this.x);
    　　}
    　　var o = {};
    　　o.x = 1;
    　　o.m = demo();
    　　o.m(); // 1 //this指向demo方法
    A2_3:apply调用
        function demo(){
    　　　　alert(this.x);
    　　}
    　　var o = {};
    　　o.x = 1;
    　　o.m = demo();
    　　o.m.apply();  //this指向window方法  --> undefined;

<----------------------------------------------------------------------------->

Q:apply和 call 什么含义，什么区别?什么时候用
A1:
    1:apply 和 call 都可以改变函数的this的指向;
A2:
    1:参数的区别apply(fn,argument[...arr])接受数组 call(fn,argument[0],argument[1]...)接受单个参数
A3:
    1:emmmmm

<----------------------------------------------------------------------------->

Q: 数组和对象有哪些原生方法，列举一下，分别是什么含义，比如连接两个数组用哪个方法，删除数组的指定项和重新组装数组(操作数据的重点)
A1:
    1:Array.pop() //删除数组尾部的一个元素并返回 example: [1,2,3].pop() // [1,2] --> 3
    2:Array.push(elment) // 往数组最后添加一个元素 example: [1,2,3].push(1) -->[1,2,3,1]
    3:Array.concat(arr) //数组合并 example: [1,2,3].concat([1,2,3]) --> [1,2,3,1,2,3]
    4:Array.indexOf(seachElment) //检索数组的位置 example:[1,2,3].indexOf(1) -->0 当没有检索到return -1
    5:Array.slice(begin,end) //返回begin end 之间的数组 example: [1,2,3,4,5].slice(0,2) --> 1,2
    6:Array.splice(index,howMany) //index(0开始) 从第几个开始删除 howMany删除几个 example:[1,2,3,4].splice(1,2) -->[1,4]
    7:Array.forEach((value,index)=>{}) //value数组的元素 index索引 
    8:Array.map((value)=>{}) //直接对数组的每个元素进行操作  [2, 3, 4, 5, 35].map(value=>{return
    value * 2}) -->[4,6,8,10,70]
    9:Array.filter(value=>{}) //对数组的元素筛选满足条件的返回 [2,3,4,5,35].filter((value)=>{return value>5}) -->[35]
    10:Array.every(value=>{}) //当数组全部满足条件返回true [2,3,4,5,35].every((value)=>{return value>5}) ->false
    11:Array.some(value=>{}) //当数组部分满足条件返回true [2,3,4,5,35].some((value)=>{return value>5}) ->true
    12:Array.reduce((currentVal,cur)=>{}) // [1, 2, 3, 4, 5].reduce(function(prev, cur, index, arr) {
     console.log(prev, cur, index);  
     return prev + cur;
})//当prev未设置初始值的时候数组第一个为默认值然后和cur累加
 